package com.apssouza.mytrade.trading.forex.session;

import com.apssouza.mytrade.trading.forex.execution.ExecutionHandler;
import com.apssouza.mytrade.trading.forex.order.OrderDto;
import com.apssouza.mytrade.trading.forex.order.OrderHandler;
import com.apssouza.mytrade.trading.forex.order.OrderOrigin;
import com.apssouza.mytrade.trading.forex.order.OrderStatus;
import com.apssouza.mytrade.trading.forex.portfolio.FilledOrderDto;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

public class OrderCreatedListener implements EventListener {

    private static Logger log = Logger.getLogger(OrderCreatedListener.class.getSimpleName());
    private final ExecutionHandler executionHandler;
    private final HistoryBookHandler historyHandler;
    private final FilledOrderListener filledOrderListener;
    private final OrderHandler orderHandler;

    public OrderCreatedListener(
            ExecutionHandler executionHandler,
            HistoryBookHandler historyHandler,
            FilledOrderListener filledOrderListener,
            OrderHandler orderHandler
    ) {
        this.executionHandler = executionHandler;
        this.historyHandler = historyHandler;
        this.filledOrderListener = filledOrderListener;
        this.orderHandler = orderHandler;
    }

    public void process(List<OrderDto> orders){
        if (orders.isEmpty()) {
            log.info("No orders");
            return;
        }

        log.info(orders.size() + " new orders");
        List<String> processedOrders = new ArrayList<>();
        List<String> exitedPositions = new ArrayList<>();
        for (OrderDto order : orders) {
            if (order.getOrigin().equals(OrderOrigin.STOP_ORDER)) {
                exitedPositions.add(order.getSymbol());
            }
        }

        for (OrderDto order : orders) {
            if (!this.canExecuteOrder(order, processedOrders, exitedPositions)) {
                continue;
            }
            this.historyHandler.addOrder(order);
            processNewOrder(processedOrders, order);
        }
    }
    private void processNewOrder(List<String> processedOrders, OrderDto order) {
        FilledOrderDto filledOrder = executionHandler.executeOrder(order);
        if (filledOrder != null) {
            filledOrderListener.process(filledOrder);
            this.historyHandler.addOrderFilled(filledOrder);
            orderHandler.updateOrderStatus(order.getId(), OrderStatus.EXECUTED);
            processedOrders.add(order.getSymbol());
        } else {
            orderHandler.updateOrderStatus(order.getId(), OrderStatus.FAILED);
        }
    }

    private boolean canExecuteOrder(OrderDto order, List<String> processedOrders, List<String> exitedPositions) {
        /**
         # Avoiding process more than one order for a currency pair in a cycle
         # possibility of more than one order by cycle:
         #     - many signals
         #     - order generated by exits and by the signals
         **/
        if (order.getOrigin().equals(OrderOrigin.SIGNAL)) {
            if (processedOrders.contains(order.getSymbol())) {
                return false;
            }

//            Not process order coming from signal if( exists a exit for the currency
            if (exitedPositions.contains(order.getSymbol())) {
                return false;
            }
        }
        return true;
    }
}
