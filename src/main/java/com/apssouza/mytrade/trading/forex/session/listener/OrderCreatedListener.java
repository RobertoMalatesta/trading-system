package com.apssouza.mytrade.trading.forex.session.listener;

import com.apssouza.mytrade.trading.forex.execution.ExecutionHandler;
import com.apssouza.mytrade.trading.forex.order.OrderDto;
import com.apssouza.mytrade.trading.forex.order.OrderHandler;
import com.apssouza.mytrade.trading.forex.order.OrderOrigin;
import com.apssouza.mytrade.trading.forex.order.OrderStatus;
import com.apssouza.mytrade.trading.forex.portfolio.FilledOrderDto;
import com.apssouza.mytrade.trading.forex.session.HistoryBookHandler;
import com.apssouza.mytrade.trading.forex.session.event.Event;
import com.apssouza.mytrade.trading.forex.session.event.EventType;
import com.apssouza.mytrade.trading.forex.session.event.OrderFilledEvent;
import com.apssouza.mytrade.trading.forex.session.event.OrderFoundEvent;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.logging.Logger;

public class OrderCreatedListener implements PropertyChangeListener {

    private static Logger log = Logger.getLogger(OrderCreatedListener.class.getSimpleName());
    private final ExecutionHandler executionHandler;
    private final HistoryBookHandler historyHandler;
    private final OrderHandler orderHandler;
    private final BlockingQueue<Event> eventQueue;

    public OrderCreatedListener(
            ExecutionHandler executionHandler,
            HistoryBookHandler historyHandler,
            OrderHandler orderHandler,
            BlockingQueue<Event> eventQueue
    ) {

        this.executionHandler = executionHandler;
        this.historyHandler = historyHandler;
        this.orderHandler = orderHandler;
        this.eventQueue = eventQueue;
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        Event event = (Event) evt.getNewValue();
        if (!(event instanceof OrderFoundEvent)) {
            return;
        }
        OrderFoundEvent orderFoundEvent = (OrderFoundEvent) event;

        List<OrderDto> orders = orderFoundEvent.getOrders();
        if (orders.isEmpty()) {
            log.info("No orders");
            return;
        }

        log.info(orders.size() + " new orders");
        List<String> processedOrders = new ArrayList<>();
        List<String> exitedPositions = new ArrayList<>();
        for (OrderDto order : orders) {
            if (order.getOrigin().equals(OrderOrigin.STOP_ORDER)) {
                exitedPositions.add(order.getSymbol());
            }
        }

        for (OrderDto order : orders) {
            if (!this.canExecuteOrder(order, processedOrders, exitedPositions)) {
                continue;
            }
            this.historyHandler.addOrder(order);
            try {
                processNewOrder(processedOrders, order, orderFoundEvent);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private void processNewOrder(List<String> processedOrders, OrderDto order, OrderFoundEvent event) throws InterruptedException {
        FilledOrderDto filledOrder = executionHandler.executeOrder(order);
        if (filledOrder != null) {
            this.eventQueue.put(new OrderFilledEvent(
                    EventType.ORDER_FILLED,
                    filledOrder.getTime(),
                    event.getPrice(),
                    filledOrder
            ));
            orderHandler.updateOrderStatus(order.getId(), OrderStatus.EXECUTED);
            processedOrders.add(order.getSymbol());
        } else {
            orderHandler.updateOrderStatus(order.getId(), OrderStatus.FAILED);
        }
    }

    private boolean canExecuteOrder(OrderDto order, List<String> processedOrders, List<String> exitedPositions) {
        /**
         # Avoiding process more than one order for a currency pair in a cycle
         # possibility of more than one order by cycle:
         #     - many signals
         #     - order generated by exits and by the signals
         **/
        if (order.getOrigin().equals(OrderOrigin.SIGNAL)) {
            if (processedOrders.contains(order.getSymbol())) {
                return false;
            }

//            Not process order coming from signal if( exists a exit for the currency
            if (exitedPositions.contains(order.getSymbol())) {
                return false;
            }
        }
        return true;
    }

}
